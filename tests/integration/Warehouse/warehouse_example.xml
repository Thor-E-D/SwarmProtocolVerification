<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>
const int NUMBER_OF_Door = 1;
typedef int[0,NUMBER_OF_Door-1] Door_t;
const int NUMBER_OF_Forklift = 2;
typedef int[0,NUMBER_OF_Forklift-1] Forklift_t;
const int NUMBER_OF_Transport = 1;
typedef int[0,NUMBER_OF_Transport-1] Transport_t;
int amountOfLogs = NUMBER_OF_Door + NUMBER_OF_Forklift + NUMBER_OF_Transport;
int currentLogToPropagate;
int amountOfPropagation = 0;
const int Request_ID = 0;
const int Close_ID = 1;
const int Deliver_ID = 2;
const int Get_ID = 3;
const int amountOfUniqueEvents = 4;
const int outerSizeBranchingList = 1;
const int innerSizeBranchingList = 2;
const int branchingList[outerSizeBranchingList][innerSizeBranchingList] ={{0, 1}};
const int isBranchingList[amountOfUniqueEvents] = {true, true, false, false};
const int isInBranchingPartion[amountOfUniqueEvents] = {0, 0, -1, -1};
typedef struct {
    int eventID;
    int emitterID;
    int orderCount;
    int basedOnOrderCount;
    int tiedTo;
    bool ignored;
} logEntryType;
int maxUpdatesSincePropagation = 1;
const int maxAmountOfTied = 1;
const int eventsTiedTo[amountOfUniqueEvents][maxAmountOfTied] = {{Request_ID}, {Request_ID}, {Request_ID}, {Request_ID}};
const int logSize = 12;
int eventOrderCounter = 1;
logEntryType tempLogEntry;
logEntryType propagationLog[logSize];
logEntryType globalLog[logSize];
urgent broadcast chan propagate_log;
urgent chan do_log_update_Door[Door_t];
urgent chan reset_Door[Door_t];
urgent broadcast chan advance_Door_Request[Door_t];
urgent broadcast chan advance_Door_Close[Door_t];
urgent broadcast chan advance_Door_Deliver[Door_t];
urgent chan do_log_update_Forklift[Forklift_t];
urgent chan reset_Forklift[Forklift_t];
urgent broadcast chan advance_Forklift_Request[Forklift_t];
urgent broadcast chan advance_Forklift_Close[Forklift_t];
urgent broadcast chan advance_Forklift_Get[Forklift_t];
urgent chan do_log_update_Transport[Transport_t];
urgent chan reset_Transport[Transport_t];
urgent broadcast chan advance_Transport_Request[Transport_t];
urgent broadcast chan advance_Transport_Close[Transport_t];
urgent broadcast chan advance_Transport_Get[Transport_t];
urgent broadcast chan advance_Transport_Deliver[Transport_t];

bool isInSubsciptions(int tmpList[amountOfUniqueEvents], int possibleEntry) {
    int i = 0;
    for (i = 0; i &lt; amountOfUniqueEvents; i++) {
        if (tmpList[i] == possibleEntry) {
            return true;
        } else if (tmpList[i] == -1) {
            return false;
        }
    }
    return false;
}

bool isIntInList(int tmpList[logSize], int possibleEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == possibleEntry) {
            return true;
        } else if (tmpList[i] == 0) {
            return false;
        }
    }
    return false;
}


void addIntToList(int &amp;tmpList[logSize], int newEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == 0) {
            tmpList[i] = newEntry;
            return;
        }
    }
}


int getEventIDfromOrderCount(int orderCount) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (globalLog[i].orderCount == orderCount) {
            return globalLog[i].eventID;
        }
    }
    return -1;
}

void setNextLogToPropagate() {
    if (amountOfPropagation &lt; amountOfLogs-2) {
        currentLogToPropagate = (currentLogToPropagate+1) % amountOfLogs;
        amountOfPropagation++;
    } else {
        // reset
        amountOfPropagation = -1;
    }
}


int getOrderCount() {
    int temp = eventOrderCounter;
    eventOrderCounter = eventOrderCounter + 1;
    return temp;
}


void setLogEntryForUpdate(int eventID, int emitterID, int basedOnOrderCount, bool ignored) {
    tempLogEntry.eventID = eventID;
    tempLogEntry.emitterID = emitterID;
    tempLogEntry.orderCount = getOrderCount();
    tempLogEntry.basedOnOrderCount = basedOnOrderCount;
    tempLogEntry.tiedTo = -1;
    tempLogEntry.ignored = ignored;
}


void findAndSetTiedTo(logEntryType &amp;tempLog[logSize]) {
    int k;
    int j;
    int i;
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            for (j = 0; j&lt;maxAmountOfTied; j++) {
                if (tempLog[i].eventID == eventsTiedTo[tempLogEntry.eventID][j] &amp;&amp; tempLog[i].tiedTo != -1) {
                    tempLogEntry.tiedTo = tempLog[i].orderCount;
                    return;
                }
            }
        }
    }
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            if (tempLog[i].emitterID == tempLogEntry.emitterID) {
                for (j = 0; j&lt;maxAmountOfTied; j++) {
                    for (k = 0; k&lt;maxAmountOfTied; k++) {
                        if (eventsTiedTo[tempLogEntry.eventID][j] == eventsTiedTo[tempLog[i].eventID][k] &amp;&amp; tempLog[i].tiedTo != -1) {
                            tempLogEntry.tiedTo = tempLog[i].tiedTo;
                            return;
                        }
                    }
                }
            }
        }
    }
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            for (j = 0; j&lt;maxAmountOfTied; j++) {
                if (tempLog[i].eventID == eventsTiedTo[tempLogEntry.eventID][j]) {
                    tempLogEntry.tiedTo = tempLog[i].orderCount;
                    return;
                }
            }
        }
    }  
}

void setPropagationLog(logEntryType tempLog[logSize]) {
    propagationLog = tempLog;
}


void updateGlobalLog() {
    int i;
    logEntryType resLog[logSize];
    int count = 0;
    bool addedEntry = false;

    for (i = 0; i &lt; (logSize); i++) {
        if (globalLog[count].orderCount == 0) {
            if (addedEntry) {
                resLog[i] = globalLog[count];
                globalLog = resLog;
                return;
            }
            resLog[i] = tempLogEntry;
            globalLog = resLog;
            return;
        }
        else if (globalLog[count].orderCount &gt; tempLogEntry.orderCount) {
            resLog[i] = tempLogEntry;
            count = count - 1;
            addedEntry = true;
        } else {
            resLog[i] = globalLog[count];
        }
        count = count + 1;
    }
    globalLog = resLog;
}

void updateLog(logEntryType &amp;tempLog[logSize]) {
    int i = 0;
    findAndSetTiedTo(tempLog);
    updateGlobalLog();
    for (i = 0; i &lt; logSize; i++) {
        if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
            tempLog[i] = tempLogEntry; // Update log
            return;
        }
    }
    return;
    // If we reach here log is full and we are in trouble
}


bool isInBranchingConflict(int partition, int eventID) {
    int i = 0;
    for (i = 0; i &lt; innerSizeBranchingList; i++) {
        if (branchingList[partition][i] == eventID) {
            return true;
        }
    }
    return false;
}

void handleBranchingEvent(logEntryType &amp;tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    int j;
    for (j = currentIndex; j &gt;= 0; j--) {
        if (resLog[j].tiedTo == tmpLogEntry.tiedTo &amp;&amp; tmpLogEntry.basedOnOrderCount == resLog[j].basedOnOrderCount) {
            if(isInBranchingConflict(isInBranchingPartion[tmpLogEntry.eventID], tmpLogEntry.eventID)) {
                tmpLogEntry.ignored = true;
            }
        }
    }
}

bool handleOwnEvent(logEntryType &amp;tmpLogEntry,logEntryType &amp;resLog[logSize], int &amp;discardedEvents[logSize], int currentIndex, int id) {
    if (isBranchingList[tmpLogEntry.eventID]) {
        handleBranchingEvent(tmpLogEntry, resLog, currentIndex);
    }
    if (isIntInList(discardedEvents, tmpLogEntry.basedOnOrderCount)) {
        tmpLogEntry.ignored = true;
    } else if (tmpLogEntry.emitterID != id) {
        int j;
        tmpLogEntry.ignored = true;
        // Check if we have already tied into this so an event we emitted that is tied to the same thing
        for (j = currentIndex; j &gt;= 0; j--) {
            if (resLog[j].emitterID == id &amp;&amp; resLog[j].eventID == tmpLogEntry.eventID &amp;&amp; resLog[j].tiedTo == tmpLogEntry.tiedTo) {
                return false;
                }
        }
        for (j = currentIndex; j &gt;= 0; j--) {
            if (resLog[j].tiedTo == tmpLogEntry.tiedTo || tmpLogEntry.tiedTo == resLog[j].orderCount) {
                resLog[j].ignored = true;
            }
        }
        return true; 
    }
    return false;
}

//ADDED
int findBasedOn(logEntryType &amp;tmpLogEntry, int &amp;subsciptions[amountOfUniqueEvents]) {
    int currentBasedOn = tmpLogEntry.basedOnOrderCount;
    int i = 0;
    for (i = logSize-1; i &gt;= 0; i--) {
        if (globalLog[i].orderCount != 0) {
            if (currentBasedOn == globalLog[i].orderCount) {
                if (isInSubsciptions(subsciptions, globalLog[i].eventID)) {
                    return globalLog[i].orderCount;
                } else {
                    currentBasedOn = globalLog[i].basedOnOrderCount;
                }
            } 
        }
    }
    return -1;
}

//ADDED
int lookForCompetingEvent(logEntryType &amp;tmpLogEntry) {
    int eventIDLookingFor = getEventIDfromOrderCount(tmpLogEntry.basedOnOrderCount);
    int basedOnOrderCount = tmpLogEntry.basedOnOrderCount;
    bool passed = false;
    bool found = false;
    int i = 0;

    //if (isBranchingList[eventIDLookingFor]) {
    //handleBranchingEvent(tmpLogEntry, resLog, currentIndex);
    //}

    for (i = logSize-1; i &gt;= 0; i--) {
        if (globalLog[i].orderCount != 0) {
            if (eventIDLookingFor == globalLog[i].eventID) {
                if (globalLog[i].orderCount == basedOnOrderCount) {
                    if (passed) {
                        return globalLog[i].orderCount;
                    }
                }
            passed = true;
            found = true;
            } else {
                if (found) {
                    // Look for the next one
                    eventIDLookingFor = globalLog[i].eventID;
                    passed = false;
                    basedOnOrderCount = globalLog[i].basedOnOrderCount;
                }
            }
        }
    }
    return -1;
}


void handleOtherEvent(logEntryType &amp;tmpLogEntry,logEntryType &amp;resLog[logSize], int &amp;discardedEvents[logSize], int &amp;subsciptions[amountOfUniqueEvents], int currentIndex) {
    int i;
    if (isBranchingList[tmpLogEntry.eventID]) {
        handleBranchingEvent(tmpLogEntry, resLog, currentIndex);
        // ADDED
        if (isIntInList(discardedEvents,findBasedOn(tmpLogEntry,subsciptions)) &amp;&amp; isIntInList(discardedEvents, tmpLogEntry.basedOnOrderCount) &amp;&amp; (!isIntInList(discardedEvents, tmpLogEntry.tiedTo))) {
                tmpLogEntry.ignored = true;
        }
    }

    if (isInSubsciptions(subsciptions, getEventIDfromOrderCount(tmpLogEntry.basedOnOrderCount))) {
        if (!isBranchingList[tmpLogEntry.eventID] &amp;&amp; isIntInList(discardedEvents, tmpLogEntry.basedOnOrderCount) || isIntInList(discardedEvents, tmpLogEntry.tiedTo)) { //ADDED
            tmpLogEntry.ignored = true;
        }
    } else {
        if (isIntInList(discardedEvents,lookForCompetingEvent(tmpLogEntry))) {
            tmpLogEntry.ignored = true;
        }
    }
    
    for (i = currentIndex; i &gt;= 0; i--) {
        if (tmpLogEntry.tiedTo != -1 &amp;&amp; resLog[i].eventID == tmpLogEntry.eventID &amp;&amp; resLog[i].tiedTo == tmpLogEntry.tiedTo) {
            tmpLogEntry.ignored = true;
        }
    }
}


void updateLogDoor(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize], int log_id_start) {    
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // We check if basedemitterID set to -2 as this is a flag for unknown
    tempLogEntry.emitterID = tempLogEntry.emitterID + log_id_start;
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = logSize-1; i &gt;= 0; i--) {
            if (tempLog[i].orderCount == 0) {
            } else { 
                if (tempLogEntry.eventID == Close_ID) {
                    if (tempLog[i].eventID == Deliver_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    tempLogEntry.basedOnOrderCount = -1;
    updateLog(tempLog);
    return;
}

void updateLogForklift(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize], int log_id_start) {    
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // We check if basedemitterID set to -2 as this is a flag for unknown
    tempLogEntry.emitterID = tempLogEntry.emitterID + log_id_start;
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = logSize-1; i &gt;= 0; i--) {
            if (tempLog[i].orderCount == 0) {
            } else { 
                if (tempLogEntry.eventID == Get_ID) {
                    if (tempLog[i].eventID == Request_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    tempLogEntry.basedOnOrderCount = -1;
    updateLog(tempLog);
    return;
}

void updateLogTransport(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize], int log_id_start) {    
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // We check if basedemitterID set to -2 as this is a flag for unknown
    tempLogEntry.emitterID = tempLogEntry.emitterID + log_id_start;
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = logSize-1; i &gt;= 0; i--) {
            if (tempLog[i].orderCount == 0) {
            } else { 
                if (tempLogEntry.eventID == Request_ID) {
                    if (tempLog[i].eventID == Deliver_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                } else if (tempLogEntry.eventID == Deliver_ID) {
                    if (tempLog[i].eventID == Get_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    tempLogEntry.basedOnOrderCount = -1;
    updateLog(tempLog);
    return;
}
</declaration>
	<template>
		<name>Door_log</name>
		<parameter>Door_t id</parameter>
		<declaration>
logEntryType currentLog[logSize];
int updatesSincePropagation = 0;
bool newUpdates = false;
int counter = 0;
int log_id_start = 0;
int emittedOrderCounts[logSize];
int discardedEvents[logSize];
bool olderEntryIgnored = false;
int subscriptions[amountOfUniqueEvents] = {Request_ID, Close_ID, Deliver_ID, -1};

logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == Request_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Deliver_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Close_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex, id + log_id_start);
    } else {
        tmpLogEntry.ignored = true;
    }
    return tmpLogEntry;
}


void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog; 
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }


        }
    }
}

</declaration>
		<location id="id0" x="-204" y="-238">
			<committed/>
		</location>
		<location id="id1" x="-748" y="-136">
			<committed/>
		</location>
		<location id="id2" x="-204" y="-136">
		</location>
		<location id="id3" x="229" y="-127">
			<committed/>
		</location>
		<location id="id4" x="-612" y="34">
			<committed/>
		</location>
		<location id="id5" x="25" y="76">
			<committed/>
		</location>
		<location id="id6" x="-561" y="153">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id7">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="-136" y="-187">newUpdates</label>
			<label kind="assignment" x="-136" y="-217">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false,
setPropagationLog(currentLog)</label>
			<nail x="-136" y="-187"/>
		</transition>
		<transition id="id8">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-272" y="-210">propagate_log!</label>
			<nail x="-272" y="-195"/>
		</transition>
		<transition id="id9">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="0" y="-66">do_log_update_Door[id]?</label>
			<label kind="assignment" x="0" y="-81">updateLogDoor(currentLog,emittedOrderCounts,log_id_start),
updatesSincePropagation++,
newUpdates := true</label>
			<nail x="0" y="-51"/>
		</transition>
		<transition id="id10">
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="guard" x="12" y="-132">!(updatesSincePropagation &gt; maxUpdatesSincePropagation)</label>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="127" y="-26">updatesSincePropagation &gt; maxUpdatesSincePropagation</label>
			<label kind="assignment" x="127" y="-56">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false</label>
		</transition>
		<transition id="id12">
			<source ref="id5"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-90" y="-45">propagate_log!</label>
			<label kind="assignment" x="-90" y="-60">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id13">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="-476" y="-136">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-476" y="-151">propagate_log?</label>
			<label kind="assignment" x="-476" y="-166">mergePropagationLog()</label>
		</transition>
		<transition id="id14">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-680" y="-66">reset_Door[id]!</label>
			<label kind="assignment" x="-680" y="-81">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id15">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-408" y="-51">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-408" y="-66">propagate_log!</label>
		</transition>
		<transition id="id16">
			<source ref="id4"/>
			<target ref="id6"/>
			<label kind="guard" x="-587" y="93">currentLog[counter].orderCount != 0</label>
		</transition>
		<transition id="id17">
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="-612" y="204">currentLog[counter].eventID == Request_ID</label>
			<label kind="synchronisation" x="-612" y="189">advance_Door_Request[id]!</label>
			<label kind="assignment" x="-612" y="174">counter++</label>
			<nail x="-578" y="204"/>
			<nail x="-646" y="204"/>
		</transition>
		<transition id="id18">
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="-646" y="238">currentLog[counter].eventID == Close_ID</label>
			<label kind="synchronisation" x="-646" y="223">advance_Door_Close[id]!</label>
			<label kind="assignment" x="-646" y="208">counter++</label>
			<nail x="-612" y="238"/>
			<nail x="-680" y="238"/>
		</transition>
		<transition id="id19">
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="-680" y="272">currentLog[counter].eventID == Deliver_ID</label>
			<label kind="synchronisation" x="-680" y="257">advance_Door_Deliver[id]!</label>
			<label kind="assignment" x="-680" y="242">counter++</label>
			<nail x="-646" y="272"/>
			<nail x="-714" y="272"/>
		</transition>
	</template>
	<template>
		<name>Door</name>
		<parameter>Door_t id</parameter>
		<declaration>
</declaration>
		<location id="id20" x="52" y="270">
			<name x="54" y="272">l1</name>
			<urgent/>
		</location>
		<location id="id21" x="52" y="147">
			<name x="54" y="149">l0</name>
			<urgent/>
		</location>
		<location id="id22" x="-289" y="34">
			<name x="-287" y="36">l3</name>
			<urgent/>
		</location>
		<init ref="id21"/>
		<transition id="id23">
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="27" y="236">reset_Door[id]?</label>
			<nail x="27" y="251"/>
		</transition>
		<transition id="id24">
			<source ref="id21"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="52" y="132">reset_Door[id]?</label>
			<nail x="22" y="117"/>
			<nail x="82" y="117"/>
		</transition>
		<transition id="id25">
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="64" y="34">reset_Door[id]?</label>
			<nail x="64" y="49"/>
		</transition>
		<transition id="id26">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="27" y="114">advance_Door_Close[id]?</label>
			<nail x="27" y="129"/>
		</transition>
		<transition id="id27">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="50" y="107">do_log_update_Door[id]!</label>
			<label kind="assignment" x="-59" y="-42">setLogEntryForUpdate(
        Close_ID,id,
        -2,false)</label>
			<nail x="50" y="122"/>
		</transition>
		<transition id="id28">
			<source ref="id21"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="64" y="156">advance_Door_Request[id]?</label>
			<nail x="64" y="171"/>
		</transition>
		<transition id="id29">
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="50" y="230">advance_Door_Deliver[id]?</label>
			<nail x="50" y="245"/>
		</transition>
	</template>
	<template>
		<name>Forklift_log</name>
		<parameter>Forklift_t id</parameter>
		<declaration>
logEntryType currentLog[logSize];
int updatesSincePropagation = 0;
bool newUpdates = false;
int counter = 0;
int log_id_start = 1;
int emittedOrderCounts[logSize];
int discardedEvents[logSize];
bool olderEntryIgnored = false;
int subscriptions[amountOfUniqueEvents] = {Request_ID, Close_ID, Get_ID, -1};

logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == Request_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Close_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Get_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex, id + log_id_start);
    } else {
        tmpLogEntry.ignored = true;
    }
    return tmpLogEntry;
}


void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog; 
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }


        }
    }
}

</declaration>
		<location id="id30" x="-204" y="-238">
			<committed/>
		</location>
		<location id="id31" x="-748" y="-136">
			<committed/>
		</location>
		<location id="id32" x="-204" y="-136">
		</location>
		<location id="id33" x="229" y="-127">
			<committed/>
		</location>
		<location id="id34" x="-612" y="34">
			<committed/>
		</location>
		<location id="id35" x="25" y="76">
			<committed/>
		</location>
		<location id="id36" x="-561" y="153">
			<committed/>
		</location>
		<init ref="id32"/>
		<transition id="id37">
			<source ref="id32"/>
			<target ref="id30"/>
			<label kind="guard" x="-136" y="-187">newUpdates</label>
			<label kind="assignment" x="-136" y="-217">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false,
setPropagationLog(currentLog)</label>
			<nail x="-136" y="-187"/>
		</transition>
		<transition id="id38">
			<source ref="id30"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="-272" y="-210">propagate_log!</label>
			<nail x="-272" y="-195"/>
		</transition>
		<transition id="id39">
			<source ref="id32"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="0" y="-66">do_log_update_Forklift[id]?</label>
			<label kind="assignment" x="0" y="-81">updateLogForklift(currentLog,emittedOrderCounts,log_id_start),
updatesSincePropagation++,
newUpdates := true</label>
			<nail x="0" y="-51"/>
		</transition>
		<transition id="id40">
			<source ref="id33"/>
			<target ref="id32"/>
			<label kind="guard" x="12" y="-132">!(updatesSincePropagation &gt; maxUpdatesSincePropagation)</label>
		</transition>
		<transition id="id41">
			<source ref="id33"/>
			<target ref="id35"/>
			<label kind="guard" x="127" y="-26">updatesSincePropagation &gt; maxUpdatesSincePropagation</label>
			<label kind="assignment" x="127" y="-56">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false</label>
		</transition>
		<transition id="id42">
			<source ref="id35"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="-90" y="-45">propagate_log!</label>
			<label kind="assignment" x="-90" y="-60">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id43">
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="guard" x="-476" y="-136">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-476" y="-151">propagate_log?</label>
			<label kind="assignment" x="-476" y="-166">mergePropagationLog()</label>
		</transition>
		<transition id="id44">
			<source ref="id31"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-680" y="-66">reset_Forklift[id]!</label>
			<label kind="assignment" x="-680" y="-81">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id45">
			<source ref="id34"/>
			<target ref="id32"/>
			<label kind="guard" x="-408" y="-51">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-408" y="-66">propagate_log!</label>
		</transition>
		<transition id="id46">
			<source ref="id34"/>
			<target ref="id36"/>
			<label kind="guard" x="-587" y="93">currentLog[counter].orderCount != 0</label>
		</transition>
		<transition id="id47">
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="guard" x="-612" y="204">currentLog[counter].eventID == Request_ID</label>
			<label kind="synchronisation" x="-612" y="189">advance_Forklift_Request[id]!</label>
			<label kind="assignment" x="-612" y="174">counter++</label>
			<nail x="-578" y="204"/>
			<nail x="-646" y="204"/>
		</transition>
		<transition id="id48">
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="guard" x="-646" y="238">currentLog[counter].eventID == Close_ID</label>
			<label kind="synchronisation" x="-646" y="223">advance_Forklift_Close[id]!</label>
			<label kind="assignment" x="-646" y="208">counter++</label>
			<nail x="-612" y="238"/>
			<nail x="-680" y="238"/>
		</transition>
		<transition id="id49">
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="guard" x="-680" y="272">currentLog[counter].eventID == Get_ID</label>
			<label kind="synchronisation" x="-680" y="257">advance_Forklift_Get[id]!</label>
			<label kind="assignment" x="-680" y="242">counter++</label>
			<nail x="-646" y="272"/>
			<nail x="-714" y="272"/>
		</transition>
	</template>
	<template>
		<name>Forklift</name>
		<parameter>Forklift_t id</parameter>
		<declaration>
</declaration>
		<location id="id50" x="77" y="270">
			<name x="79" y="272">l1</name>
			<urgent/>
		</location>
		<location id="id51" x="77" y="147">
			<name x="79" y="149">l0</name>
			<urgent/>
		</location>
		<location id="id52" x="77" y="25">
			<name x="79" y="27">l3</name>
			<urgent/>
		</location>
		<init ref="id51"/>
		<transition id="id53">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="45" y="242">reset_Forklift[id]?</label>
			<nail x="45" y="257"/>
		</transition>
		<transition id="id54">
			<source ref="id51"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="77" y="132">reset_Forklift[id]?</label>
			<nail x="47" y="117"/>
			<nail x="107" y="117"/>
		</transition>
		<transition id="id55">
			<source ref="id52"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="77" y="35">reset_Forklift[id]?</label>
			<nail x="77" y="50"/>
		</transition>
		<transition id="id56">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="64" y="231">advance_Forklift_Get[id]?</label>
			<nail x="64" y="246"/>
		</transition>
		<transition id="id57">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="77" y="230">do_log_update_Forklift[id]!</label>
			<label kind="assignment" x="77" y="215">setLogEntryForUpdate(
        Get_ID,id,
        -2,false)</label>
			<nail x="77" y="245"/>
		</transition>
		<transition id="id58">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="92" y="156">advance_Forklift_Request[id]?</label>
			<nail x="92" y="171"/>
		</transition>
		<transition id="id59">
			<source ref="id51"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="64" y="109">advance_Forklift_Close[id]?</label>
			<nail x="64" y="124"/>
		</transition>
	</template>
	<template>
		<name>Transport_log</name>
		<parameter>Transport_t id</parameter>
		<declaration>
logEntryType currentLog[logSize];
int updatesSincePropagation = 0;
bool newUpdates = false;
int counter = 0;
int log_id_start = 3;
int emittedOrderCounts[logSize];
int discardedEvents[logSize];
bool olderEntryIgnored = false;
int subscriptions[amountOfUniqueEvents] = {Request_ID, Close_ID, Get_ID, Deliver_ID};

logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == Get_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Close_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, subscriptions, currentIndex);
    } else if (currentEventType == Request_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex, id + log_id_start);
    } else if (currentEventType == Deliver_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex, id + log_id_start);
    } else {
        tmpLogEntry.ignored = true;
    }
    return tmpLogEntry;
}


void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog; 
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }


        }
    }
}

</declaration>
		<location id="id60" x="-204" y="-238">
			<committed/>
		</location>
		<location id="id61" x="-748" y="-136">
			<committed/>
		</location>
		<location id="id62" x="-204" y="-136">
		</location>
		<location id="id63" x="229" y="-127">
			<committed/>
		</location>
		<location id="id64" x="-612" y="34">
			<committed/>
		</location>
		<location id="id65" x="25" y="76">
			<committed/>
		</location>
		<location id="id66" x="-561" y="153">
			<committed/>
		</location>
		<init ref="id62"/>
		<transition id="id67">
			<source ref="id62"/>
			<target ref="id60"/>
			<label kind="guard" x="-136" y="-187">newUpdates</label>
			<label kind="assignment" x="-136" y="-217">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false,
setPropagationLog(currentLog)</label>
			<nail x="-136" y="-187"/>
		</transition>
		<transition id="id68">
			<source ref="id60"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-272" y="-210">propagate_log!</label>
			<nail x="-272" y="-195"/>
		</transition>
		<transition id="id69">
			<source ref="id62"/>
			<target ref="id63"/>
			<label kind="synchronisation" x="0" y="-66">do_log_update_Transport[id]?</label>
			<label kind="assignment" x="0" y="-81">updateLogTransport(currentLog,emittedOrderCounts,log_id_start),
updatesSincePropagation++,
newUpdates := true</label>
			<nail x="0" y="-51"/>
		</transition>
		<transition id="id70">
			<source ref="id63"/>
			<target ref="id62"/>
			<label kind="guard" x="12" y="-132">!(updatesSincePropagation &gt; maxUpdatesSincePropagation)</label>
		</transition>
		<transition id="id71">
			<source ref="id63"/>
			<target ref="id65"/>
			<label kind="guard" x="127" y="-26">updatesSincePropagation &gt; maxUpdatesSincePropagation</label>
			<label kind="assignment" x="127" y="-56">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false</label>
		</transition>
		<transition id="id72">
			<source ref="id65"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-90" y="-45">propagate_log!</label>
			<label kind="assignment" x="-90" y="-60">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id73">
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="guard" x="-476" y="-136">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-476" y="-151">propagate_log?</label>
			<label kind="assignment" x="-476" y="-166">mergePropagationLog()</label>
		</transition>
		<transition id="id74">
			<source ref="id61"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-680" y="-66">reset_Transport[id]!</label>
			<label kind="assignment" x="-680" y="-81">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id75">
			<source ref="id64"/>
			<target ref="id62"/>
			<label kind="guard" x="-408" y="-51">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-408" y="-66">propagate_log!</label>
		</transition>
		<transition id="id76">
			<source ref="id64"/>
			<target ref="id66"/>
			<label kind="guard" x="-587" y="93">currentLog[counter].orderCount != 0</label>
		</transition>
		<transition id="id77">
			<source ref="id66"/>
			<target ref="id64"/>
			<label kind="guard" x="-612" y="204">currentLog[counter].eventID == Request_ID</label>
			<label kind="synchronisation" x="-612" y="189">advance_Transport_Request[id]!</label>
			<label kind="assignment" x="-612" y="174">counter++</label>
			<nail x="-578" y="204"/>
			<nail x="-646" y="204"/>
		</transition>
		<transition id="id78">
			<source ref="id66"/>
			<target ref="id64"/>
			<label kind="guard" x="-646" y="238">currentLog[counter].eventID == Close_ID</label>
			<label kind="synchronisation" x="-646" y="223">advance_Transport_Close[id]!</label>
			<label kind="assignment" x="-646" y="208">counter++</label>
			<nail x="-612" y="238"/>
			<nail x="-680" y="238"/>
		</transition>
		<transition id="id79">
			<source ref="id66"/>
			<target ref="id64"/>
			<label kind="guard" x="-680" y="272">currentLog[counter].eventID == Get_ID</label>
			<label kind="synchronisation" x="-680" y="257">advance_Transport_Get[id]!</label>
			<label kind="assignment" x="-680" y="242">counter++</label>
			<nail x="-646" y="272"/>
			<nail x="-714" y="272"/>
		</transition>
		<transition id="id80">
			<source ref="id66"/>
			<target ref="id64"/>
			<label kind="guard" x="-714" y="306">currentLog[counter].eventID == Deliver_ID</label>
			<label kind="synchronisation" x="-714" y="291">advance_Transport_Deliver[id]!</label>
			<label kind="assignment" x="-714" y="276">counter++</label>
			<nail x="-680" y="306"/>
			<nail x="-748" y="306"/>
		</transition>
	</template>
	<template>
		<name>Transport</name>
		<parameter>Transport_t id</parameter>
		<declaration>
int loop_counter = 0;
</declaration>
		<location id="id81" x="61" y="270">
			<name x="63" y="272">l2</name>
			<urgent/>
		</location>
		<location id="id82" x="37" y="25">
			<name x="39" y="27">l1</name>
			<urgent/>
		</location>
		<location id="id83" x="100" y="147">
			<name x="102" y="149">l0</name>
			<urgent/>
		</location>
		<location id="id84" x="190" y="25">
			<name x="192" y="27">l3</name>
			<urgent/>
		</location>
		<init ref="id83"/>
		<transition id="id85">
			<source ref="id81"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="45" y="232">reset_Transport[id]?</label>
			<nail x="45" y="247"/>
		</transition>
		<transition id="id86">
			<source ref="id82"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="59" y="30">reset_Transport[id]?</label>
			<nail x="59" y="45"/>
		</transition>
		<transition id="id87">
			<source ref="id83"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="100" y="132">reset_Transport[id]?</label>
			<nail x="70" y="117"/>
			<nail x="130" y="117"/>
		</transition>
		<transition id="id88">
			<source ref="id84"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="194" y="35">reset_Transport[id]?</label>
			<nail x="194" y="50"/>
		</transition>
		<transition id="id89">
			<source ref="id83"/>
			<target ref="id82"/>
			<label kind="synchronisation" x="65" y="121">advance_Transport_Request[id]?</label>
			<nail x="65" y="136"/>
		</transition>
		<transition id="id90">
			<source ref="id83"/>
			<target ref="id82"/>
			<label kind="guard" x="80" y="126">loop_counter &lt; 2</label>
			<label kind="synchronisation" x="80" y="111">do_log_update_Transport[id]!</label>
			<label kind="assignment" x="80" y="96">setLogEntryForUpdate(
        Request_ID,id,
        -2,false), loop_counter++</label>
			<nail x="80" y="126"/>
		</transition>
		<transition id="id91">
			<source ref="id81"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="68" y="230">advance_Transport_Deliver[id]?</label>
			<nail x="68" y="245"/>
		</transition>
		<transition id="id92">
			<source ref="id81"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="85" y="236">do_log_update_Transport[id]!</label>
			<label kind="assignment" x="85" y="221">setLogEntryForUpdate(
        Deliver_ID,id,
        -2,false)</label>
			<nail x="85" y="251"/>
		</transition>
		<transition id="id93">
			<source ref="id82"/>
			<target ref="id81"/>
			<label kind="synchronisation" x="19" y="32">advance_Transport_Get[id]?</label>
			<nail x="19" y="47"/>
		</transition>
		<transition id="id94">
			<source ref="id83"/>
			<target ref="id84"/>
			<label kind="synchronisation" x="116" y="110">advance_Transport_Close[id]?</label>
			<nail x="116" y="125"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.
system Door, Door_log, Forklift, Forklift_log, Transport, Transport_log;
</system>
	<queries>
		<query>
			<formula>A[] forall(i:Door_t) forall(j:Forklift_t) forall(t:Transport_t) deadlock imply Door(i).l3 and Forklift(j).l3 and Transport(t).l3</formula>
			<comment/>
			<option key="--diagnostic" value="0"/>
			<result outcome="failure" type="quality" timestamp="2024-11-07 16:18:53 +0100">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
	</queries>
</nta>
