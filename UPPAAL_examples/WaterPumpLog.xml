<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// We first declare the number of each role
const int NUMBER_OF_Pump = 2;
typedef int[0,NUMBER_OF_Pump-1] Pump_t;

const int NUMBER_OF_Robot = 2;
typedef int[0,NUMBER_OF_Robot-1] Robot_t;


int amountOfLogs = NUMBER_OF_Pump + NUMBER_OF_Robot;
int currentLogToPropagate;
int amountOfPropagation = 0;


// The eventTypes unique ID
const int DockAvailable_ID = 0;
const int RobotIsDocked_ID = 1;
const int WaterSupplied_ID = 2;
const int RobotIsUndocked_ID = 3;


typedef struct {
    int eventID;
    int emitterID;
    int orderCount;
    int basedOnOrderCount;
    bool ignored;
} logEntryType;


// ------------ shared data -----------

// Size of log
const int logSize = 10;

// The counter for the order
int eventOrderCounter = 1;

// Log entry to update must be global in to send data from one process to another
// might need one of these for each log.
logEntryType tempLogEntry;

// log For propagation
logEntryType propagationLog[logSize];


// ------------ channels --------------

//The log synchronization channels
urgent broadcast chan propagate_log;

// Pump channels
urgent chan do_log_update_pump[Pump_t];
urgent chan reset_pump[Pump_t];
urgent broadcast chan advance_pump_dock_available[Pump_t];
urgent broadcast chan advance_pump_robot_is_docked[Pump_t];
urgent broadcast chan advance_pump_water_supplied[Pump_t];
urgent broadcast chan advance_pump_robot_is_undocked[Pump_t];

// Robot channels
urgent chan do_log_update_robot[Robot_t];
urgent chan reset_robot[Robot_t];
urgent broadcast chan advance_robot_dock_available[Robot_t];
urgent broadcast chan advance_robot_robot_is_docked[Robot_t];
urgent broadcast chan advance_robot_water_supplied[Robot_t];
urgent broadcast chan advance_robot_robot_is_undocked[Robot_t];


// --------- Functions ---------------

// Function to check if number is in list
bool isIntInList(int tmpList[logSize], int possibleEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == possibleEntry) {
            return true;
        } else if (tmpList[i] == 0) {
            return false;
        }
    }
    return false;
}


// Function for adding element to list
void addIntToList(int &amp;tmpList[logSize], int newEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == 0) {
            tmpList[i] = newEntry;
            return;
        }
    }
}


void setNextLogToPropagate() {
    if (amountOfPropagation &lt; amountOfLogs-2) {
        currentLogToPropagate = (currentLogToPropagate+1) % amountOfLogs;
        amountOfPropagation++;
    } else {
        // reset
        amountOfPropagation = -1;
    }
}


// Get orderCounter and increment it
int getOrderCount() {
    int temp = eventOrderCounter;
    eventOrderCounter = eventOrderCounter + 1;
    return temp;
}

// Set new log entry
void setLogEntryForUpdate(int eventID, int emitterID, int basedOnOrderCount, bool ignored) {
    tempLogEntry.eventID = eventID;
    tempLogEntry.emitterID = emitterID;
    tempLogEntry.orderCount = getOrderCount();
    tempLogEntry.basedOnOrderCount = basedOnOrderCount;
    tempLogEntry.ignored = ignored;
}

void setPropagationLog(logEntryType tempLog[logSize]) {
    propagationLog = tempLog;
}


// Update currentLog and return index for new entry
void updateLog(logEntryType &amp;tempLog[logSize]) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
            tempLog[i] = tempLogEntry; // Update log
            return;
        }
    }
    return;
    // If we reach here log is full and we are in trouble
}

// Special function for checking if new log entry has not set the emitter ID it is based on yet and then sets it
void updateLogRobot(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize]) {    
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // We check if basedemitterID set to -2 as this is a flag for unknown
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = 0; i &lt; logSize; i++) {
            if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
                updateLog(tempLog);
                return;
            } else {
                if (tempLogEntry.eventID == RobotIsDocked_ID) {
                    // check if previous event is ignored == false
                    if (tempLog[i].eventID == DockAvailable_ID &amp;&amp; !tempLog[i].ignored) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                } else if (tempLogEntry.eventID == RobotIsUndocked_ID) {
                    // check if previous event is ignored == false
                    if (tempLog[i].eventID == WaterSupplied_ID &amp;&amp; !tempLog[i].ignored) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    updateLog(tempLog);
    return;
}

// Special function for checking if new log entry has not set the emitter ID it is based on yet and then sets it
void updateLogPump(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize]) {
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // First we check if basedemitterID set to -2 as this is a flag for unknown
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = 0; i &lt; logSize; i++) {
            if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
                updateLog(tempLog);
                return;
            } else {
                if (tempLogEntry.eventID == WaterSupplied_ID) {
                    // check if previous event is ignored == false
                    if (tempLog[i].eventID == RobotIsDocked_ID &amp;&amp; !tempLog[i].ignored) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    updateLog(tempLog);
    return;
}



// Function for extending a log length
void extendLogLength() {} //TODO

















</declaration>
	<template>
		<name>Robot_log</name>
		<parameter>Robot_t id</parameter>
		<declaration>// The log
logEntryType currentLog[logSize];


int counter = 0;

// Unique id overall logs
int log_id_start = 0;

// list for orderCounts we emitted
int emittedOrderCounts[logSize];

// list of orderCounts of events we have discarded
int discardedEvents[logSize];

bool olderEntryIgnored = false;

// --------- Functions ---------------

// Here is the business logic for handling each different event type.
logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == DockAvailable_ID) {
        // It is a beginning event so we do not care who broadcasted it
    } else if (currentEventType == RobotIsDocked_ID) {
        if (tmpLogEntry.emitterID != id) {
            int j;
            tmpLogEntry.ignored = true;

            for (j = currentIndex; j &gt;= 0; j--) {
                  if (resLog[j].eventID == DockAvailable_ID &amp;&amp; resLog[j].orderCount == tmpLogEntry.basedOnOrderCount) {
                  // We must ignore the dockAvailable since someone else claimed it first
                  resLog[j].ignored = true;
                  olderEntryIgnored = true;
                  return tmpLogEntry;
                }
            }
        }
        

    } else if (currentEventType == WaterSupplied_ID) {
        // ignore if not based on own events
        if (!(isIntInList(emittedOrderCounts, tmpLogEntry.basedOnOrderCount))) {
            tmpLogEntry.ignored = true;
        }
    } else if (currentEventType == RobotIsUndocked_ID) {
        // Ignore if not basedOnEmitterID = id
        if (tmpLogEntry.emitterID != id) {
            tmpLogEntry.ignored = true;
        }
    }
    return tmpLogEntry;
}


void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog; 
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }


        }
    }
}
</declaration>
		<location id="id0" x="0" y="-136">
			<committed/>
		</location>
		<location id="id1" x="-51" y="51">
			<committed/>
		</location>
		<location id="id2" x="-612" y="34">
			<committed/>
		</location>
		<location id="id3" x="-204" y="-136">
		</location>
		<location id="id4" x="-561" y="153">
			<committed/>
		</location>
		<location id="id5" x="-748" y="-136">
			<committed/>
		</location>
		<init ref="id3"/>
		<transition id="id6">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="-663" y="-136">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-544" y="-187">propagate_log?</label>
			<label kind="assignment" x="-578" y="-161">mergePropagationLog()</label>
			<nail x="-476" y="-136"/>
		</transition>
		<transition id="id7">
			<source ref="id5"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-833" y="-59">reset_robot[id]!</label>
			<label kind="assignment" x="-858" y="-34">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id8">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-1164" y="76">currentLog[counter].eventID == WaterSupplied_ID</label>
			<label kind="synchronisation" x="-1096" y="102">advance_robot_water_supplied[id]!</label>
			<label kind="assignment" x="-969" y="59">counter++</label>
			<nail x="-748" y="102"/>
			<nail x="-748" y="68"/>
		</transition>
		<transition id="id9">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-1190" y="170">currentLog[counter].eventID == RobotIsUndocked_ID</label>
			<label kind="synchronisation" x="-1156" y="195">advance_robot_robot_is_undocked[id]!</label>
			<label kind="assignment" x="-1037" y="144">counter++</label>
			<nail x="-748" y="204"/>
			<nail x="-748" y="153"/>
		</transition>
		<transition id="id10">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-765" y="314">currentLog[counter].eventID == RobotIsDocked_ID</label>
			<label kind="synchronisation" x="-756" y="340">advance_robot_robot_is_docked[id]!</label>
			<label kind="assignment" x="-705" y="289">counter++</label>
			<nail x="-748" y="306"/>
			<nail x="-748" y="246"/>
		</transition>
		<transition id="id11">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-8" y="-34">updateLogRobot(currentLog,emittedOrderCounts),
currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs</label>
		</transition>
		<transition id="id12">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="-620" y="-51">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-578" y="-25">propagate_log!</label>
		</transition>
		<transition id="id13">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-544" y="178">currentLog[counter].eventID == DockAvailable_ID</label>
			<label kind="synchronisation" x="-544" y="212">advance_robot_dock_available[id]!</label>
			<label kind="assignment" x="-535" y="161">counter++</label>
			<nail x="-561" y="170"/>
			<nail x="-561" y="238"/>
			<nail x="-612" y="238"/>
		</transition>
		<transition id="id14">
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="-561" y="76">currentLog[counter].orderCount != 0</label>
			<nail x="-586" y="93"/>
		</transition>
		<transition id="id15">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-229" y="-51">propagate_log!</label>
			<label kind="assignment" x="-365" y="-25">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id16">
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-170" y="-161">do_log_update_robot[id]?</label>
		</transition>
	</template>
	<template>
		<name>Pump_log</name>
		<parameter>Pump_t id</parameter>
		<declaration>// The log
logEntryType currentLog[logSize];


int counter = 0;

// Unique id overall logs
int log_id_start = NUMBER_OF_Robot;

// list for orderCounts we emitted
int emittedOrderCounts[logSize];

// list of orderCounts of events we have discarded
int discardedEvents[logSize];

bool olderEntryIgnored = false;

// --------- Functions ---------------

// Here is the business logic for handling each different event type.
logEntryType handleLogEntry(logEntryType tmpLogEntry) {    

    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == DockAvailable_ID) {
        // Ignore all other than own
        if (tmpLogEntry.emitterID != id) {
            tmpLogEntry.ignored = true;
        }
    } else if (currentEventType == RobotIsDocked_ID) {
        if (!(isIntInList(emittedOrderCounts, tmpLogEntry.basedOnOrderCount))) {
            tmpLogEntry.ignored = true;
        }
    } else if (currentEventType == WaterSupplied_ID) {
        // Ignore all other than own
        if (tmpLogEntry.emitterID != id) {
            tmpLogEntry.ignored = true;
        }
    } else if (currentEventType == RobotIsUndocked_ID) {
        if (!(isIntInList(emittedOrderCounts, tmpLogEntry.basedOnOrderCount))) {
            tmpLogEntry.ignored = true;
        }
    }
    return tmpLogEntry;
}



void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog;
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }
        }
    }
}



</declaration>
		<location id="id17" x="-306" y="-238">
		</location>
		<location id="id18" x="-102" y="-238">
			<committed/>
		</location>
		<location id="id19" x="-85" y="-42">
			<committed/>
		</location>
		<location id="id20" x="-748" y="-238">
			<committed/>
		</location>
		<location id="id21" x="-595" y="60">
			<committed/>
		</location>
		<location id="id22" x="-646" y="-59">
			<committed/>
		</location>
		<init ref="id17"/>
		<transition id="id23">
			<source ref="id17"/>
			<target ref="id20"/>
			<label kind="guard" x="-714" y="-238">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-586" y="-289">propagate_log?</label>
			<label kind="assignment" x="-612" y="-272">mergePropagationLog()</label>
			<nail x="-484" y="-238"/>
		</transition>
		<transition id="id24">
			<source ref="id20"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-833" y="-170">reset_pump[id]!</label>
			<label kind="assignment" x="-824" y="-144">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id25">
			<source ref="id22"/>
			<target ref="id17"/>
			<label kind="guard" x="-646" y="-178">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-628" y="-165">propagate_log!</label>
		</transition>
		<transition id="id26">
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="assignment" x="-76" y="-127">updateLogPump(currentLog,emittedOrderCounts),
currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs</label>
		</transition>
		<transition id="id27">
			<source ref="id19"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-323" y="-144">propagate_log!</label>
			<label kind="assignment" x="-365" y="-102">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id28">
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-272" y="-280">do_log_update_pump[id]?</label>
		</transition>
		<transition id="id29">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="-1198" y="-25">currentLog[counter].eventID == WaterSupplied_ID</label>
			<label kind="synchronisation" x="-1130" y="9">advance_pump_water_supplied[id]!</label>
			<label kind="assignment" x="-1011" y="-51">counter++</label>
			<nail x="-782" y="9"/>
			<nail x="-782" y="-25"/>
		</transition>
		<transition id="id30">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="-1215" y="76">currentLog[counter].eventID == RobotIsUndocked_ID</label>
			<label kind="synchronisation" x="-1190" y="102">advance_pump_robot_is_undocked[id]!</label>
			<label kind="assignment" x="-1079" y="59">counter++</label>
			<nail x="-782" y="111"/>
			<nail x="-782" y="60"/>
		</transition>
		<transition id="id31">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="-799" y="221">currentLog[counter].eventID == RobotIsDocked_ID</label>
			<label kind="synchronisation" x="-790" y="246">advance_pump_robot_is_docked[id]!</label>
			<label kind="assignment" x="-739" y="196">counter++</label>
			<nail x="-782" y="213"/>
			<nail x="-782" y="153"/>
		</transition>
		<transition id="id32">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="-578" y="93">currentLog[counter].eventID == DockAvailable_ID</label>
			<label kind="synchronisation" x="-578" y="119">advance_pump_dock_available[id]!</label>
			<label kind="assignment" x="-569" y="68">counter++</label>
			<nail x="-595" y="77"/>
			<nail x="-595" y="145"/>
			<nail x="-646" y="145"/>
		</transition>
		<transition id="id33">
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="guard" x="-620" y="-8">currentLog[counter].orderCount != 0</label>
			<nail x="-620" y="8"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Pump</name>
		<parameter>Pump_t id</parameter>
		<declaration>// Place local declarations here.
</declaration>
		<location id="id34" x="-510" y="68">
			<name x="-688" y="59">ClearingDock</name>
			<urgent/>
		</location>
		<location id="id35" x="-510" y="-204">
			<name x="-697" y="-238">WaitingForRobotToDock</name>
			<urgent/>
		</location>
		<location id="id36" x="-202" y="-204">
			<name x="-212" y="-238">PumpingWater</name>
			<urgent/>
		</location>
		<location id="id37" x="-202" y="68">
			<name x="-304" y="85">WaitingForRobotToUndock</name>
			<urgent/>
		</location>
		<location id="id38" x="136" y="68">
			<name x="126" y="34">Done</name>
		</location>
		<init ref="id34"/>
		<transition id="id39">
			<source ref="id38"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-255" y="144">reset_pump[id]?</label>
			<nail x="68" y="136"/>
			<nail x="-408" y="136"/>
		</transition>
		<transition id="id40">
			<source ref="id34"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-569" y="136">reset_pump[id]?</label>
			<nail x="-476" y="136"/>
			<nail x="-544" y="136"/>
		</transition>
		<transition id="id41">
			<source ref="id36"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-68" y="-195">do_log_update_pump[id]!</label>
			<label kind="assignment" x="8" y="-136">setLogEntryForUpdate(
WaterSupplied_ID,id,
-2,false)</label>
			<nail x="0" y="-136"/>
			<nail x="0" y="0"/>
		</transition>
		<transition id="id42">
			<source ref="id37"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-408" y="34">reset_pump[id]?</label>
		</transition>
		<transition id="id43">
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-357" y="-68">reset_pump[id]?</label>
		</transition>
		<transition id="id44">
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-442" y="-161">reset_pump[id]?</label>
			<nail x="-374" y="-68"/>
		</transition>
		<transition id="id45">
			<source ref="id34"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-663" y="-102">do_log_update_pump[id]!</label>
			<label kind="assignment" x="-663" y="-76">setLogEntryForUpdate(
DockAvailable_ID,id,
-1,false)</label>
			<nail x="-510" y="0"/>
			<nail x="-510" y="-136"/>
		</transition>
		<transition id="id46">
			<source ref="id34"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-969" y="-110">advance_pump_dock_available[id]?</label>
			<nail x="-680" y="0"/>
			<nail x="-680" y="-136"/>
		</transition>
		<transition id="id47">
			<source ref="id37"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-187" y="42">advance_pump_robot_is_undocked[id]?</label>
		</transition>
		<transition id="id48">
			<source ref="id36"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-195" y="-85">advance_pump_water_supplied[id]?</label>
		</transition>
		<transition id="id49">
			<source ref="id35"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-501" y="-229">advance_pump_robot_is_docked[id]?</label>
		</transition>
	</template>
	<template>
		<name>Robot</name>
		<parameter>Robot_t id</parameter>
		<location id="id50" x="-66" y="102">
			<name x="-178" y="110">Undocking</name>
			<urgent/>
		</location>
		<location id="id51" x="272" y="102">
			<name x="262" y="68">Done</name>
		</location>
		<location id="id52" x="-66" y="-170">
			<name x="-42" y="-195">WaitingForWater</name>
			<urgent/>
		</location>
		<location id="id53" x="-374" y="-170">
			<name x="-442" y="-204">Docking</name>
			<urgent/>
		</location>
		<location id="id54" x="-374" y="102">
			<name x="-595" y="76">WaitingForAvailableDock</name>
			<urgent/>
		</location>
		<init ref="id54"/>
		<transition id="id55">
			<source ref="id51"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-93" y="246">reset_robot[id]?</label>
			<nail x="374" y="102"/>
			<nail x="374" y="280"/>
			<nail x="-272" y="272"/>
		</transition>
		<transition id="id56">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="0" y="170">do_log_update_robot[id]!</label>
			<label kind="assignment" x="-110" y="195">setLogEntryForUpdate(RobotIsUndocked_ID,id,-2,false)</label>
			<nail x="0" y="170"/>
			<nail x="238" y="170"/>
		</transition>
		<transition id="id57">
			<source ref="id53"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="-331" y="-289">do_log_update_robot[id]!</label>
			<label kind="assignment" x="-433" y="-263">setLogEntryForUpdate(RobotIsDocked_ID,id,-2,false)</label>
			<nail x="-306" y="-238"/>
			<nail x="-136" y="-238"/>
		</transition>
		<transition id="id58">
			<source ref="id54"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-493" y="178">reset_robot[id]?</label>
			<nail x="-408" y="170"/>
			<nail x="-340" y="170"/>
		</transition>
		<transition id="id59">
			<source ref="id50"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-263" y="51">reset_robot[id]?</label>
			<nail x="-221" y="-34"/>
		</transition>
		<transition id="id60">
			<source ref="id52"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-229" y="-85">reset_robot[id]?</label>
		</transition>
		<transition id="id61">
			<source ref="id53"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-340" y="-110">reset_robot[id]?</label>
			<nail x="-221" y="-34"/>
		</transition>
		<transition id="id62">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-59" y="76">advance_robot_robot_is_undocked[id]?</label>
		</transition>
		<transition id="id63">
			<source ref="id52"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-51" y="-51">advance_robot_water_supplied[id]?</label>
		</transition>
		<transition id="id64">
			<source ref="id53"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="-357" y="-187">advance_robot_robot_is_docked[id]?</label>
		</transition>
		<transition id="id65">
			<source ref="id54"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="-654" y="-42">advance_robot_dock_available[id]?</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.
system Pump, Pump_log, Robot, Robot_log;
</system>
	<queries>
		<query>
			<formula>A[] forall(i:Robot_t) forall(j:Pump_t) deadlock imply Robot(i).Done and Pump(j).Done</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-09-26 15:38:04 +0200">
			</result>
		</query>
	</queries>
</nta>
