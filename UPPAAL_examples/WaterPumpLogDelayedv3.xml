<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// We first declare the number of each role
const int NUMBER_OF_Pump = 1;
typedef int[0,NUMBER_OF_Pump-1] Pump_t;

const int NUMBER_OF_Robot = 2;
typedef int[0,NUMBER_OF_Robot-1] Robot_t;


int amountOfLogs = NUMBER_OF_Pump + NUMBER_OF_Robot;
int currentLogToPropagate;
int amountOfPropagation = 0;


// The eventTypes unique ID
const int DockAvailable_ID = 0;
const int RobotIsDocked_ID = 1;
const int WaterSupplied_ID = 2;
const int RobotIsUndocked_ID = 3;

const int amountOfUniqueEvents = 4;

typedef struct {
    int eventID;
    int emitterID;
    int orderCount;
    int basedOnOrderCount;
    int tiedTo;
    bool ignored;
} logEntryType;

// How many times a machine can transition before being forced to propagate.
int maxUpdatesSincePropagation = 1;


const int maxAmountOfTied = 1;
const int eventsTiedTo[amountOfUniqueEvents][maxAmountOfTied] = {{-1}, {DockAvailable_ID}, {DockAvailable_ID}, {DockAvailable_ID}};

// ------------ shared data -----------

// Size of log
const int logSize = 10;

// The counter for the order
int eventOrderCounter = 1;

// Log entry to update must be global in to send data from one process to another
// might need one of these for each log.
logEntryType tempLogEntry;

// log For propagation
logEntryType propagationLog[logSize];


// ------------ channels --------------

//The log synchronization channels
urgent broadcast chan propagate_log;

// Pump channels
urgent chan do_log_update_pump[Pump_t];
urgent chan reset_pump[Pump_t];
urgent broadcast chan advance_pump_dock_available[Pump_t];
urgent broadcast chan advance_pump_robot_is_docked[Pump_t];
urgent broadcast chan advance_pump_water_supplied[Pump_t];
urgent broadcast chan advance_pump_robot_is_undocked[Pump_t];

// Robot channels
urgent chan do_log_update_robot[Robot_t];
urgent chan reset_robot[Robot_t];
urgent broadcast chan advance_robot_dock_available[Robot_t];
urgent broadcast chan advance_robot_robot_is_docked[Robot_t];
urgent broadcast chan advance_robot_water_supplied[Robot_t];
urgent broadcast chan advance_robot_robot_is_undocked[Robot_t];


// --------- Functions ---------------

// Function to check if number is in list
bool isIntInList(int tmpList[logSize], int possibleEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == possibleEntry) {
            return true;
        } else if (tmpList[i] == 0) {
            return false;
        }
    }
    return false;
}


// Function for adding element to list
void addIntToList(int &amp;tmpList[logSize], int newEntry) {
    int i = 0;
    for (i = 0; i &lt; logSize; i++) {
        if (tmpList[i] == 0) {
            tmpList[i] = newEntry;
            return;
        }
    }
}


void setNextLogToPropagate() {
    if (amountOfPropagation &lt; amountOfLogs-2) {
        currentLogToPropagate = (currentLogToPropagate+1) % amountOfLogs;
        amountOfPropagation++;
    } else {
        // reset
        amountOfPropagation = -1;
    }
}


// Get orderCounter and increment it
int getOrderCount() {
    int temp = eventOrderCounter;
    eventOrderCounter = eventOrderCounter + 1;
    return temp;
}

// Set new log entry
void setLogEntryForUpdate(int eventID, int emitterID, int basedOnOrderCount, bool ignored) {
    tempLogEntry.eventID = eventID;
    tempLogEntry.emitterID = emitterID;
    tempLogEntry.orderCount = getOrderCount();
    tempLogEntry.basedOnOrderCount = basedOnOrderCount;
    tempLogEntry.tiedTo = -1;
    tempLogEntry.ignored = ignored;
}

void setPropagationLog(logEntryType tempLog[logSize]) {
    propagationLog = tempLog;
}

void findAndSetTiedTo(logEntryType &amp;tempLog[logSize]) {
    int k;
    int j;
    int i;
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            for (j = 0; j&lt;maxAmountOfTied; j++) {
                if (tempLog[i].eventID == eventsTiedTo[tempLogEntry.eventID][j] &amp;&amp; tempLog[i].tiedTo != -1) {
                    tempLogEntry.tiedTo = tempLog[i].orderCount;
                    return;
                }
            }
        }
    }  
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            if (tempLog[i].emitterID == tempLogEntry.emitterID) {
                for (j = 0; j&lt;maxAmountOfTied; j++) {
                    for (k = 0; k&lt;maxAmountOfTied; k++) {
                        if (eventsTiedTo[tempLogEntry.eventID][j] == eventsTiedTo[tempLog[i].eventID][k] &amp;&amp; tempLog[i].tiedTo != -1) {
                            tempLogEntry.tiedTo = tempLog[i].tiedTo;
                            return;
                        }
                    }
                }
            }
        }
    }
    for(i = logSize-1; i &gt;= 0; i--) {
        if (tempLog[i].orderCount != 0) {
            for (j = 0; j&lt;maxAmountOfTied; j++) {
                if (tempLog[i].eventID == eventsTiedTo[tempLogEntry.eventID][j]) {
                    tempLogEntry.tiedTo = tempLog[i].orderCount;
                    return;
                }
            }
        }
    }  
}

// Update currentLog and return index for new entry
void updateLog(logEntryType &amp;tempLog[logSize]) {
    int i = 0;
    findAndSetTiedTo(tempLog);
    for (i = 0; i &lt; logSize; i++) {
        if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
            tempLog[i] = tempLogEntry; // Update log
            return;
        }
    }
    return;
    // If we reach here log is full and we are in trouble
}

// Handle events with same type that the machine emits. returns if older entries in the resLog have been ignored.
bool handleOwnEvent(logEntryType &amp;tmpLogEntry,logEntryType &amp;resLog[logSize], int &amp;discardedEvents[logSize], int currentIndex, int id) {
    if (isIntInList(discardedEvents, tmpLogEntry.basedOnOrderCount)) {
        tmpLogEntry.ignored = true;
    } else if (tmpLogEntry.emitterID != id) {
        int j;
        tmpLogEntry.ignored = true;
        // Check if we have already tied into this so an event we emitted that is tied to the same thing
        for (j = currentIndex; j &gt;= 0; j--) {
            if (resLog[j].emitterID == id &amp;&amp; resLog[j].eventID == tmpLogEntry.eventID &amp;&amp; resLog[j].tiedTo == tmpLogEntry.tiedTo) {
                return false;
                }
        }
        for (j = currentIndex; j &gt;= 0; j--) {
            if (resLog[j].tiedTo == tmpLogEntry.tiedTo || tmpLogEntry.tiedTo == resLog[j].orderCount) {
                resLog[j].ignored = true;
            }
        }
        return true; 
    }
    return false;
}

// Handles events that other machines emit but this machine subscribe to.
void handleOtherEvent(logEntryType &amp;tmpLogEntry,logEntryType &amp;resLog[logSize], int &amp;discardedEvents[logSize], int &amp;emittedOrderCounts[logSize], int currentIndex) {
    int i;
    if (isIntInList(discardedEvents, tmpLogEntry.basedOnOrderCount) || isIntInList(discardedEvents, tmpLogEntry.tiedTo)) {
        tmpLogEntry.ignored = true;
    }
    
    for (i = currentIndex; i &gt;= 0; i--) {
        if (tmpLogEntry.tiedTo != -1 &amp;&amp; resLog[i].eventID == tmpLogEntry.eventID &amp;&amp; resLog[i].tiedTo == tmpLogEntry.tiedTo) {
            tmpLogEntry.ignored = true;
        }
    }
}


// Special function for checking if new log entry has not set the emitter ID it is based on yet and then sets it
void updateLogRobot(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize], int log_id_start) {    
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // We check if basedemitterID set to -2 as this is a flag for unknown
    tempLogEntry.emitterID = tempLogEntry.emitterID + log_id_start;
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = logSize-1; i &gt;= 0; i--) {
            if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
            } else {
                if (tempLogEntry.eventID == RobotIsDocked_ID) {
                    if (tempLog[i].eventID == DockAvailable_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                } else if (tempLogEntry.eventID == RobotIsUndocked_ID) {
                    if (tempLog[i].eventID == WaterSupplied_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    updateLog(tempLog);
    return;
}

// Special function for checking if new log entry has not set the emitter ID it is based on yet and then sets it
void updateLogPump(logEntryType &amp;tempLog[logSize], int &amp;emittedOrderCounts[logSize], int log_id_start) {
    addIntToList(emittedOrderCounts, tempLogEntry.orderCount);
    // First we check if basedemitterID set to -2 as this is a flag for unknown
    tempLogEntry.emitterID = tempLogEntry.emitterID + log_id_start;
    if (tempLogEntry.basedOnOrderCount == -2) {
        int i = 0;
        for (i = logSize-1; i &gt;= 0; i--) {
            if (tempLog[i].orderCount == 0) { // Log entry is unused since orderCount can never be 0
            } else {
                if (tempLogEntry.eventID == WaterSupplied_ID) {
                    if (tempLog[i].eventID == RobotIsDocked_ID) {
                        tempLogEntry.basedOnOrderCount = tempLog[i].orderCount;
                        updateLog(tempLog);
                        return;
                    }
                }
            }
        }
    }
    updateLog(tempLog);
    return;
}



// Function for extending a log length
void extendLogLength() {} //TODO

















</declaration>
	<template>
		<name>Robot_log</name>
		<parameter>Robot_t id</parameter>
		<declaration>// The log
logEntryType currentLog[logSize];


int updatesSincePropagation = 0;
bool newUpdates = false;

int counter = 0;

// Unique id overall logs
int log_id_start = 0;

// list for orderCounts we emitted
int emittedOrderCounts[logSize];

// list of orderCounts of events we have discarded
int discardedEvents[logSize];

bool olderEntryIgnored = false;

// --------- Functions ---------------

// Here is the business logic for handling each different event type.
logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {
    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == DockAvailable_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, emittedOrderCounts, currentIndex);
    } else if (currentEventType == RobotIsDocked_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex,id + log_id_start);
    } else if (currentEventType == WaterSupplied_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, emittedOrderCounts, currentIndex);
    } else if (currentEventType == RobotIsUndocked_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex,id + log_id_start);
    }
    return tmpLogEntry;
}


void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog; 
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }


        }
    }
}
</declaration>
		<location id="id0" x="229" y="-127">
			<committed/>
		</location>
		<location id="id1" x="25" y="76">
			<committed/>
		</location>
		<location id="id2" x="-612" y="34">
			<committed/>
		</location>
		<location id="id3" x="-204" y="-136">
		</location>
		<location id="id4" x="-561" y="153">
			<committed/>
		</location>
		<location id="id5" x="-748" y="-136">
			<committed/>
		</location>
		<location id="id6" x="-204" y="-238">
			<committed/>
		</location>
		<init ref="id3"/>
		<transition id="id7">
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="guard" x="-93" y="-102">!(updatesSincePropagation 
&gt; maxUpdatesSincePropagation)</label>
			<nail x="25" y="-25"/>
		</transition>
		<transition id="id8">
			<source ref="id6"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-85" y="-246">propagate_log!</label>
			<nail x="-102" y="-238"/>
		</transition>
		<transition id="id9">
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="guard" x="-391" y="-212">newUpdates</label>
			<label kind="assignment" x="-561" y="-297">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false,
setPropagationLog(currentLog)</label>
			<nail x="-306" y="-238"/>
		</transition>
		<transition id="id10">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="-663" y="-136">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-544" y="-187">propagate_log?</label>
			<label kind="assignment" x="-578" y="-161">mergePropagationLog()</label>
			<nail x="-476" y="-136"/>
		</transition>
		<transition id="id11">
			<source ref="id5"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-833" y="-59">reset_robot[id]!</label>
			<label kind="assignment" x="-858" y="-34">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id12">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-1164" y="76">currentLog[counter].eventID == WaterSupplied_ID</label>
			<label kind="synchronisation" x="-1096" y="102">advance_robot_water_supplied[id]!</label>
			<label kind="assignment" x="-969" y="59">counter++</label>
			<nail x="-748" y="102"/>
			<nail x="-748" y="68"/>
		</transition>
		<transition id="id13">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-1190" y="170">currentLog[counter].eventID == RobotIsUndocked_ID</label>
			<label kind="synchronisation" x="-1156" y="195">advance_robot_robot_is_undocked[id]!</label>
			<label kind="assignment" x="-1037" y="144">counter++</label>
			<nail x="-748" y="204"/>
			<nail x="-748" y="153"/>
		</transition>
		<transition id="id14">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-765" y="314">currentLog[counter].eventID == RobotIsDocked_ID</label>
			<label kind="synchronisation" x="-756" y="340">advance_robot_robot_is_docked[id]!</label>
			<label kind="assignment" x="-705" y="289">counter++</label>
			<nail x="-748" y="306"/>
			<nail x="-748" y="246"/>
		</transition>
		<transition id="id15">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="153" y="-34">updatesSincePropagation 
&gt; maxUpdatesSincePropagation</label>
			<label kind="assignment" x="93" y="34">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false</label>
		</transition>
		<transition id="id16">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="-620" y="-51">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-578" y="-25">propagate_log!</label>
		</transition>
		<transition id="id17">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-544" y="178">currentLog[counter].eventID == DockAvailable_ID</label>
			<label kind="synchronisation" x="-544" y="212">advance_robot_dock_available[id]!</label>
			<label kind="assignment" x="-535" y="161">counter++</label>
			<nail x="-561" y="170"/>
			<nail x="-561" y="238"/>
			<nail x="-612" y="238"/>
		</transition>
		<transition id="id18">
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="-561" y="76">currentLog[counter].orderCount != 0</label>
			<nail x="-586" y="93"/>
		</transition>
		<transition id="id19">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-187" y="25">propagate_log!</label>
			<label kind="assignment" x="-323" y="-8">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id20">
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-93" y="-178">do_log_update_robot[id]?</label>
			<label kind="assignment" x="127" y="-212">updateLogRobot(currentLog,emittedOrderCounts, log_id_start),
updatesSincePropagation++,
newUpdates := true</label>
		</transition>
	</template>
	<template>
		<name>Pump_log</name>
		<parameter>Pump_t id</parameter>
		<declaration>// The log
logEntryType currentLog[logSize];


int updatesSincePropagation = 0;
bool newUpdates = false;

int counter = 0;

// Unique id overall logs
int log_id_start = NUMBER_OF_Robot;

// list for orderCounts we emitted
int emittedOrderCounts[logSize];

// list of orderCounts of events we have discarded
int discardedEvents[logSize];

bool olderEntryIgnored = false;

// --------- Functions ---------------

// Here is the business logic for handling each different event type.
logEntryType handleLogEntry(logEntryType tmpLogEntry,logEntryType &amp;resLog[logSize], int currentIndex) {    

    // We first find the event Type
    int currentEventType = tmpLogEntry.eventID;
    if (currentEventType == DockAvailable_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex,id + log_id_start);
    } else if (currentEventType == RobotIsDocked_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, emittedOrderCounts, currentIndex);
    } else if (currentEventType == WaterSupplied_ID) {
        olderEntryIgnored = handleOwnEvent(tmpLogEntry, resLog, discardedEvents, currentIndex, id + log_id_start);
    } else if (currentEventType == RobotIsUndocked_ID) {
        handleOtherEvent(tmpLogEntry, resLog, discardedEvents, emittedOrderCounts, currentIndex);
    }
    return tmpLogEntry;
}



void mergePropagationLog() {
    int currentLogCounter = 0;
    int propagatedLogCounter = 0;

    logEntryType resLog[logSize];

    logEntryType currentLogEntry;
    logEntryType propagatedLogEntry;
    logEntryType tmpLogEntry;

    bool currentLogDone = false;
    bool propagatedLogDone = false;

    int i;
    for (i = 0; i &lt; (logSize * 2); i++) {
        currentLogEntry = currentLog[currentLogCounter];
        propagatedLogEntry = propagationLog[propagatedLogCounter];
        
        // TODO if one is done then we can simply append the rest
        if (currentLogEntry.orderCount == 0) {
            currentLogDone = true;
        }
        if (propagatedLogEntry.orderCount == 0) {
            propagatedLogDone = true;
        }

        // If both are done we are done.
        if (currentLogDone &amp;&amp; propagatedLogDone) {
            currentLog = resLog;
            return;
        }
        
        // If one entry is invalid then we have to choose the other one
        if (currentLogDone) {
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else if (propagatedLogDone) {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (propagatedLogEntry.orderCount == currentLogEntry.orderCount) { //They are the same event we use one but skip both
            propagatedLogCounter++;
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        } else if (currentLogEntry.orderCount &gt; propagatedLogEntry.orderCount) { // Both entries are valid we can now figure out which one is first
            propagatedLogCounter++;
            tmpLogEntry = propagatedLogEntry;
        } else {
            currentLogCounter++;
            tmpLogEntry = currentLogEntry;
        }
        
        // If it was already ignored we don't have to add it else we have to handle it
        if (isIntInList(discardedEvents, tmpLogEntry.orderCount)) {
            i--;
        } else {
            tmpLogEntry = handleLogEntry(tmpLogEntry,resLog,i-1);
            if (tmpLogEntry.ignored) {
                // Value should be discarded
                i--;
                addIntToList(discardedEvents, tmpLogEntry.orderCount);
            } else {
                resLog[i] = tmpLogEntry;
            }
            if (olderEntryIgnored) {
                int j;
                int h = 0;
                logEntryType tmpLog[logSize];
                for(j = 0; j &lt; logSize; j++) {
                    if (resLog[j].orderCount == 0) {
                        j = logSize;
                    } else if (!resLog[j].ignored) {
                        tmpLog[h] = resLog[j];
                        h++;
                    } else {
                        i--;
                        addIntToList(discardedEvents, resLog[j].orderCount);
                    }
                }
                resLog = tmpLog;
                olderEntryIgnored = false;
            }
        }
    }
}



</declaration>
		<location id="id21" x="-306" y="-238">
		</location>
		<location id="id22" x="195" y="-238">
			<committed/>
		</location>
		<location id="id23" x="-93" y="-42">
			<committed/>
		</location>
		<location id="id24" x="-748" y="-238">
			<committed/>
		</location>
		<location id="id25" x="-595" y="60">
			<committed/>
		</location>
		<location id="id26" x="-646" y="-59">
			<committed/>
		</location>
		<location id="id27" x="-306" y="-374">
			<committed/>
		</location>
		<init ref="id21"/>
		<transition id="id28">
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="guard" x="-170" y="-204">!(updatesSincePropagation 
&gt; maxUpdatesSincePropagation)</label>
			<nail x="178" y="-238"/>
			<nail x="-76" y="-144"/>
		</transition>
		<transition id="id29">
			<source ref="id27"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-195" y="-331">propagate_log!</label>
			<nail x="-170" y="-374"/>
		</transition>
		<transition id="id30">
			<source ref="id21"/>
			<target ref="id27"/>
			<label kind="guard" x="-484" y="-314">newUpdates</label>
			<label kind="assignment" x="-680" y="-425">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false,
setPropagationLog(currentLog)</label>
			<nail x="-442" y="-374"/>
		</transition>
		<transition id="id31">
			<source ref="id21"/>
			<target ref="id24"/>
			<label kind="guard" x="-714" y="-238">currentLogToPropagate == log_id_start + id</label>
			<label kind="synchronisation" x="-586" y="-289">propagate_log?</label>
			<label kind="assignment" x="-612" y="-272">mergePropagationLog()</label>
			<nail x="-484" y="-238"/>
		</transition>
		<transition id="id32">
			<source ref="id24"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-833" y="-170">reset_pump[id]!</label>
			<label kind="assignment" x="-824" y="-144">counter := 0,
setNextLogToPropagate()</label>
		</transition>
		<transition id="id33">
			<source ref="id26"/>
			<target ref="id21"/>
			<label kind="guard" x="-646" y="-178">currentLog[counter].orderCount == 0</label>
			<label kind="synchronisation" x="-628" y="-165">propagate_log!</label>
		</transition>
		<transition id="id34">
			<source ref="id22"/>
			<target ref="id23"/>
			<label kind="guard" x="102" y="-153">updatesSincePropagation 
&gt; maxUpdatesSincePropagation</label>
			<label kind="assignment" x="-25" y="-85">currentLogToPropagate = (log_id_start + id + 1) % amountOfLogs,
updatesSincePropagation := 0,
newUpdates := false</label>
		</transition>
		<transition id="id35">
			<source ref="id23"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-323" y="-144">propagate_log!</label>
			<label kind="assignment" x="-416" y="-119">setPropagationLog(currentLog)</label>
		</transition>
		<transition id="id36">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-127" y="-272">do_log_update_pump[id]?</label>
			<label kind="assignment" x="85" y="-323">updateLogPump(currentLog,emittedOrderCounts, log_id_start),
updatesSincePropagation++,
newUpdates := true</label>
		</transition>
		<transition id="id37">
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="guard" x="-1198" y="-25">currentLog[counter].eventID == WaterSupplied_ID</label>
			<label kind="synchronisation" x="-1130" y="9">advance_pump_water_supplied[id]!</label>
			<label kind="assignment" x="-1011" y="-51">counter++</label>
			<nail x="-782" y="9"/>
			<nail x="-782" y="-25"/>
		</transition>
		<transition id="id38">
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="guard" x="-1215" y="76">currentLog[counter].eventID == RobotIsUndocked_ID</label>
			<label kind="synchronisation" x="-1190" y="102">advance_pump_robot_is_undocked[id]!</label>
			<label kind="assignment" x="-1079" y="59">counter++</label>
			<nail x="-782" y="111"/>
			<nail x="-782" y="60"/>
		</transition>
		<transition id="id39">
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="guard" x="-799" y="221">currentLog[counter].eventID == RobotIsDocked_ID</label>
			<label kind="synchronisation" x="-790" y="246">advance_pump_robot_is_docked[id]!</label>
			<label kind="assignment" x="-739" y="196">counter++</label>
			<nail x="-782" y="213"/>
			<nail x="-782" y="153"/>
		</transition>
		<transition id="id40">
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="guard" x="-578" y="93">currentLog[counter].eventID == DockAvailable_ID</label>
			<label kind="synchronisation" x="-578" y="119">advance_pump_dock_available[id]!</label>
			<label kind="assignment" x="-569" y="68">counter++</label>
			<nail x="-595" y="77"/>
			<nail x="-595" y="145"/>
			<nail x="-646" y="145"/>
		</transition>
		<transition id="id41">
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="guard" x="-620" y="-8">currentLog[counter].orderCount != 0</label>
			<nail x="-620" y="8"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Pump</name>
		<parameter>Pump_t id</parameter>
		<declaration>// Place local declarations here.
</declaration>
		<location id="id42" x="-510" y="68">
			<name x="-688" y="59">ClearingDock</name>
			<urgent/>
		</location>
		<location id="id43" x="-510" y="-204">
			<name x="-697" y="-238">WaitingForRobotToDock</name>
			<urgent/>
		</location>
		<location id="id44" x="-202" y="-204">
			<name x="-212" y="-238">PumpingWater</name>
			<urgent/>
		</location>
		<location id="id45" x="-202" y="68">
			<name x="-304" y="85">WaitingForRobotToUndock</name>
			<urgent/>
		</location>
		<location id="id46" x="136" y="68">
			<name x="126" y="34">Done</name>
		</location>
		<init ref="id42"/>
		<transition id="id47">
			<source ref="id46"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-255" y="144">reset_pump[id]?</label>
			<nail x="68" y="136"/>
			<nail x="-408" y="136"/>
		</transition>
		<transition id="id48">
			<source ref="id42"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-569" y="136">reset_pump[id]?</label>
			<nail x="-476" y="136"/>
			<nail x="-544" y="136"/>
		</transition>
		<transition id="id49">
			<source ref="id44"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-68" y="-195">do_log_update_pump[id]!</label>
			<label kind="assignment" x="8" y="-136">setLogEntryForUpdate(
WaterSupplied_ID,id,
-2,false)</label>
			<nail x="0" y="-136"/>
			<nail x="0" y="0"/>
		</transition>
		<transition id="id50">
			<source ref="id45"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-408" y="34">reset_pump[id]?</label>
		</transition>
		<transition id="id51">
			<source ref="id44"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-357" y="-68">reset_pump[id]?</label>
		</transition>
		<transition id="id52">
			<source ref="id43"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-442" y="-161">reset_pump[id]?</label>
			<nail x="-374" y="-68"/>
		</transition>
		<transition id="id53">
			<source ref="id42"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-663" y="-102">do_log_update_pump[id]!</label>
			<label kind="assignment" x="-663" y="-76">setLogEntryForUpdate(
DockAvailable_ID,id,
-1,false)</label>
			<nail x="-510" y="0"/>
			<nail x="-510" y="-136"/>
		</transition>
		<transition id="id54">
			<source ref="id42"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-969" y="-110">advance_pump_dock_available[id]?</label>
			<nail x="-680" y="0"/>
			<nail x="-680" y="-136"/>
		</transition>
		<transition id="id55">
			<source ref="id45"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="-187" y="42">advance_pump_robot_is_undocked[id]?</label>
		</transition>
		<transition id="id56">
			<source ref="id44"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-195" y="-85">advance_pump_water_supplied[id]?</label>
		</transition>
		<transition id="id57">
			<source ref="id43"/>
			<target ref="id44"/>
			<label kind="synchronisation" x="-501" y="-229">advance_pump_robot_is_docked[id]?</label>
		</transition>
	</template>
	<template>
		<name>Robot</name>
		<parameter>Robot_t id</parameter>
		<location id="id58" x="-66" y="102">
			<name x="-178" y="110">Undocking</name>
			<urgent/>
		</location>
		<location id="id59" x="272" y="102">
			<name x="262" y="68">Done</name>
		</location>
		<location id="id60" x="-66" y="-170">
			<name x="-42" y="-195">WaitingForWater</name>
			<urgent/>
		</location>
		<location id="id61" x="-374" y="-170">
			<name x="-442" y="-204">Docking</name>
			<urgent/>
		</location>
		<location id="id62" x="-374" y="102">
			<name x="-595" y="76">WaitingForAvailableDock</name>
			<urgent/>
		</location>
		<init ref="id62"/>
		<transition id="id63">
			<source ref="id59"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-93" y="246">reset_robot[id]?</label>
			<nail x="374" y="102"/>
			<nail x="374" y="280"/>
			<nail x="-272" y="272"/>
		</transition>
		<transition id="id64">
			<source ref="id58"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="0" y="170">do_log_update_robot[id]!</label>
			<label kind="assignment" x="-110" y="195">setLogEntryForUpdate(RobotIsUndocked_ID,id,-2,false)</label>
			<nail x="0" y="170"/>
			<nail x="238" y="170"/>
		</transition>
		<transition id="id65">
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-331" y="-289">do_log_update_robot[id]!</label>
			<label kind="assignment" x="-433" y="-263">setLogEntryForUpdate(RobotIsDocked_ID,id,-2,false)</label>
			<nail x="-306" y="-238"/>
			<nail x="-136" y="-238"/>
		</transition>
		<transition id="id66">
			<source ref="id62"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-493" y="178">reset_robot[id]?</label>
			<nail x="-408" y="170"/>
			<nail x="-340" y="170"/>
		</transition>
		<transition id="id67">
			<source ref="id58"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-263" y="51">reset_robot[id]?</label>
			<nail x="-221" y="-34"/>
		</transition>
		<transition id="id68">
			<source ref="id60"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-229" y="-85">reset_robot[id]?</label>
		</transition>
		<transition id="id69">
			<source ref="id61"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-340" y="-110">reset_robot[id]?</label>
			<nail x="-221" y="-34"/>
		</transition>
		<transition id="id70">
			<source ref="id58"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="-59" y="76">advance_robot_robot_is_undocked[id]?</label>
		</transition>
		<transition id="id71">
			<source ref="id60"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-51" y="-51">advance_robot_water_supplied[id]?</label>
		</transition>
		<transition id="id72">
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-357" y="-187">advance_robot_robot_is_docked[id]?</label>
		</transition>
		<transition id="id73">
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-654" y="-42">advance_robot_dock_available[id]?</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.
system Pump, Pump_log, Robot, Robot_log;
</system>
	<queries>
		<query>
			<formula>A[] forall(i:Robot_t) forall(j:Pump_t) deadlock imply Robot(i).Done and Pump(j).Done</formula>
			<comment>For any delay but with same amout of robots and pumps</comment>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2024-11-01 13:58:39 +0100">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] deadlock imply ((Robot(0).Done and Robot(1).WaitingForAvailableDock) or (Robot(1).Done and Robot(0).WaitingForAvailableDock)) and Pump(0).Done</formula>
			<comment>For 1 pump 2 robots</comment>
			<result outcome="success" type="quality" timestamp="2024-11-01 11:29:47 +0100">
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; forall(i:Robot_t) Robot(i).WaitingForWater</formula>
			<comment>For delay in propagation of 1</comment>
			<result outcome="success" type="quality" timestamp="2024-11-10 14:23:36 +0100">
			</result>
		</query>
		<query>
			<formula>Robot(0).Done --&gt; not Robot(1).Done</formula>
			<comment>For any delay in propagation with 2 robots one pump</comment>
			<option key="--diagnostic" value="0"/>
		</query>
		<query>
			<formula>A[] deadlock imply Pump(0).Done</formula>
			<comment/>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2024-10-30 15:20:31 +0100">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A&lt;&gt; forall(j:Pump_t) Pump(j).Done</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-10-30 15:36:45 +0100">
			</result>
		</query>
		<query>
			<formula>A&lt;&gt; forall(i:Robot_t) (Robot(i).Done or Robot(i).WaitingForAvailableDock)</formula>
			<comment/>
		</query>
	</queries>
</nta>
